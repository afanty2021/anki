# 集合同步

<cite>
**本文档引用的文件**  
- [rslib/src/sync/collection/mod.rs](file://rslib/src/sync/collection/mod.rs)
- [rslib/src/sync/collection/protocol.rs](file://rslib/src/sync/collection/protocol.rs)
- [rslib/src/sync/collection/start.rs](file://rslib/src/sync/collection/start.rs)
- [rslib/src/sync/collection/changes.rs](file://rslib/src/sync/collection/changes.rs)
- [rslib/src/sync/collection/chunks.rs](file://rslib/src/sync/collection/chunks.rs)
- [rslib/src/sync/collection/finish.rs](file://rslib/src/sync/collection/finish.rs)
- [rslib/src/sync/collection/normal.rs](file://rslib/src/sync/collection/normal.rs)
- [rslib/src/sync/collection/status.rs](file://rslib/src/sync/collection/status.rs)
- [rslib/src/sync/collection/meta.rs](file://rslib/src/sync/collection/meta.rs)
- [rslib/src/sync/collection/sanity.rs](file://rslib/src/sync/collection/sanity.rs)
- [rslib/src/sync/collection/graves.rs](file://rslib/src/sync/collection/graves.rs)
- [rslib/src/sync/collection/upload.rs](file://rslib/src/sync/collection/upload.rs)
- [rslib/src/sync/collection/download.rs](file://rslib/src/sync/collection/download.rs)
</cite>

## 目录
1. [简介](#简介)
2. [同步会话生命周期](#同步会话生命周期)
3. [变更检测算法](#变更检测算法)
4. [增量同步协议](#增量同步协议)
5. [冲突解决机制](#冲突解决机制)
6. [数据序列化与校验](#数据序列化与校验)
7. [事务处理](#事务处理)
8. [正常同步与快速同步](#正常同步与快速同步)
9. [协议消息格式](#协议消息格式)
10. [状态机转换](#状态机转换)
11. [错误恢复策略](#错误恢复策略)
12. [常见问题处理](#常见问题处理)
13. [性能优化建议](#性能优化建议)

## 简介
Anki的集合同步系统实现了双向增量同步机制，确保多个设备间的集合数据一致性。该系统通过检测本地和远程集合的修改时间戳、模式变更和更新序列号（USN）来决定同步策略。同步过程分为元数据检查、删除处理、未分块变更同步、分块数据同步、完整性检查和最终化等阶段。系统支持正常同步和全量同步两种模式，能够处理部分同步失败、数据不一致和版本兼容性等复杂场景。

## 同步会话生命周期
Anki的同步会话遵循严格的生命周期管理，从状态检查开始，经过多个协调阶段，最终完成同步或处理错误。整个过程确保数据一致性和事务完整性。

```mermaid
sequenceDiagram
participant 客户端 as 客户端
participant 服务器 as 服务器
客户端->>服务器 : meta请求
服务器-->>客户端 : 返回远程元数据
客户端->>客户端 : 比较本地与远程元数据
客户端->>服务器 : start请求
服务器-->>客户端 : 返回远程删除项
客户端->>客户端 : 处理本地删除项
客户端->>服务器 : apply_graves请求
服务器->>客户端 : 确认
客户端->>服务器 : apply_changes请求
服务器-->>客户端 : 返回远程未分块变更
客户端->>客户端 : 应用远程未分块变更
客户端->>服务器 : chunk请求
服务器-->>客户端 : 返回数据块
客户端->>客户端 : 应用数据块
客户端->>服务器 : apply_chunk请求
服务器->>客户端 : 确认
客户端->>服务器 : sanityCheck2请求
服务器-->>客户端 : 返回完整性检查结果
客户端->>服务器 : finish请求
服务器-->>客户端 : 返回新的修改时间
客户端->>客户端 : 最终化同步状态
```

**Diagram sources**
- [rslib/src/sync/collection/normal.rs](file://rslib/src/sync/collection/normal.rs#L100-L170)
- [rslib/src/sync/collection/status.rs](file://rslib/src/sync/collection/status.rs#L40-L55)

**Section sources**
- [rslib/src/sync/collection/normal.rs](file://rslib/src/sync/collection/normal.rs#L1-L178)
- [rslib/src/sync/collection/status.rs](file://rslib/src/sync/collection/status.rs#L1-L57)

## 变更检测算法
Anki使用多维度的变更检测算法来确定同步需求。系统通过比较本地和远程集合的修改时间戳、模式时间戳和更新序列号来判断数据是否发生变化。

```mermaid
flowchart TD
Start([开始变更检测]) --> GetLocalMeta["获取本地元数据"]
GetLocalMeta --> GetRemoteMeta["获取远程元数据"]
GetRemoteMeta --> CompareSchema{"模式时间戳相同?"}
CompareSchema --> |否| FullSync["需要全量同步"]
CompareSchema --> |是| CompareMod{"修改时间戳相同?"}
CompareMod --> |是| NoChanges["无需同步"]
CompareMod --> |否| NormalSync["需要正常同步"]
NoChanges --> End([结束])
FullSync --> End
NormalSync --> End
```

**Diagram sources**
- [rslib/src/sync/collection/status.rs](file://rslib/src/sync/collection/status.rs#L10-L57)
- [rslib/src/sync/collection/meta.rs](file://rslib/src/sync/collection/meta.rs#L100-L185)

**Section sources**
- [rslib/src/sync/collection/status.rs](file://rslib/src/sync/collection/status.rs#L1-L57)
- [rslib/src/sync/collection/meta.rs](file://rslib/src/sync/collection/meta.rs#L1-L185)

## 增量同步协议
Anki的增量同步协议采用分阶段、分块的方式传输数据变更，确保大集合的高效同步。协议将变更分为未分块变更和分块数据两类进行处理。

### 未分块变更同步
未分块变更包括牌组、牌组配置、牌型和标签等元数据变更。这些变更在单个请求中批量传输。

```mermaid
flowchart TD
Start([开始未分块变更同步]) --> GatherLocal["收集本地变更"]
GatherLocal --> SendApplyChanges["发送apply_changes请求"]
SendApplyChanges --> ReceiveRemote["接收远程变更"]
ReceiveRemote --> ApplyRemote["应用远程变更"]
ApplyRemote --> UpdateProgress["更新进度"]
UpdateProgress --> End([完成未分块变更同步])
```

**Diagram sources**
- [rslib/src/sync/collection/changes.rs](file://rslib/src/sync/collection/changes.rs#L50-L325)

### 分块数据同步
分块数据包括卡片、笔记和复习记录等大量数据。这些数据被分割成固定大小的块进行传输，每块包含250个对象。

```mermaid
flowchart TD
Start([开始分块同步]) --> Loop{"还有更多块?"}
Loop --> |是| GetChunk["获取数据块"]
GetChunk --> SendOrReceive["发送或接收块"]
SendOrReceive --> UpdateProgress["更新进度"]
UpdateProgress --> CheckCancel["检查取消"]
CheckCancel --> Loop
Loop --> |否| End([完成分块同步])
```

**Diagram sources**
- [rslib/src/sync/collection/chunks.rs](file://rslib/src/sync/collection/chunks.rs#L100-L432)

**Section sources**
- [rslib/src/sync/collection/changes.rs](file://rslib/src/sync/collection/changes.rs#L1-L325)
- [rslib/src/sync/collection/chunks.rs](file://rslib/src/sync/collection/chunks.rs#L1-L432)

## 冲突解决机制
Anki的冲突解决机制基于最后写入获胜（Last Write Wins）原则，通过比较对象的修改时间戳来决定保留哪个版本。

```mermaid
classDiagram
class NoteEntry {
+id : NoteId
+mtime : TimestampSecs
+usn : Usn
+tags : String
+fields : String
}
class CardEntry {
+id : CardId
+mtime : TimestampSecs
+usn : Usn
+due : i32
+ivl : u32
}
class RevlogEntry {
+id : RevlogId
+ease : u8
+ivl : u32
+last_interval : u32
+factor : u16
+time : u32
+type : RevlogType
+event : RevlogEvent
+card_id : CardId
+review_start_millis : u32
+button_chosen : u8
+total_time : u32
+next_due : i32
+old_due : i32
+new_interval : u32
}
class Collection {
+add_or_update_note_if_newer(entry : NoteEntry, pending_usn : Usn) Result
+add_or_update_card_if_newer(entry : CardEntry, pending_usn : Usn) Result
+merge_revlog(entries : Vec<RevlogEntry>) Result
}
Collection --> NoteEntry : "使用"
Collection --> CardEntry : "使用"
Collection --> RevlogEntry : "使用"
```

**Diagram sources**
- [rslib/src/sync/collection/chunks.rs](file://rslib/src/sync/collection/chunks.rs#L200-L300)

**Section sources**
- [rslib/src/sync/collection/chunks.rs](file://rslib/src/sync/collection/chunks.rs#L1-L432)

## 数据序列化与校验
Anki使用JSON格式进行数据序列化，并通过完整性检查确保数据一致性。系统在同步完成后执行双向完整性检查。

```mermaid
flowchart TD
Start([开始数据序列化]) --> Serialize["序列化对象为JSON"]
Serialize --> Compress["可选压缩"]
Compress --> Transmit["传输数据"]
Transmit --> Receive["接收数据"]
Receive --> Decompress["可选解压缩"]
Decompress --> Deserialize["反序列化JSON"]
Deserialize --> Validate["验证数据完整性"]
Validate --> End([完成数据处理])
```

**Diagram sources**
- [rslib/src/sync/collection/protocol.rs](file://rslib/src/sync/collection/protocol.rs#L1-L112)

**Section sources**
- [rslib/src/sync/collection/protocol.rs](file://rslib/src/sync/collection/protocol.rs#L1-L112)

## 事务处理
Anki的同步过程在数据库事务中执行，确保原子性和一致性。如果同步失败，系统会回滚所有更改。

```mermaid
flowchart TD
Start([开始同步]) --> BeginTx["开始事务"]
BeginTx --> ProcessChanges["处理变更"]
ProcessChanges --> CheckError{"发生错误?"}
CheckError --> |是| Rollback["回滚事务"]
CheckError --> |否| Commit["提交事务"]
Rollback --> HandleError["处理错误"]
HandleError --> End([结束])
Commit --> End
```

**Diagram sources**
- [rslib/src/sync/collection/normal.rs](file://rslib/src/sync/collection/normal.rs#L120-L150)

**Section sources**
- [rslib/src/sync/collection/normal.rs](file://rslib/src/sync/collection/normal.rs#L1-L178)

## 正常同步与快速同步
Anki支持两种同步模式：正常同步和全量同步（快速同步）。系统根据元数据比较结果决定使用哪种模式。

```mermaid
flowchart TD
Start([同步模式选择]) --> CompareMeta["比较元数据"]
CompareMeta --> SchemaChanged{"模式变更?"}
SchemaChanged --> |是| FullSync["全量同步"]
SchemaChanged --> |否| ModChanged{"修改时间变更?"}
ModChanged --> |是| NormalSync["正常同步"]
ModChanged --> |否| NoSync["无需同步"]
FullSync --> End([完成])
NormalSync --> End
NoSync --> End
```

**Diagram sources**
- [rslib/src/sync/collection/meta.rs](file://rslib/src/sync/collection/meta.rs#L150-L185)

**Section sources**
- [rslib/src/sync/collection/meta.rs](file://rslib/src/sync/collection/meta.rs#L1-L185)

## 协议消息格式
Anki同步协议定义了多种消息类型，每种类型对应特定的同步操作。消息通过HTTP端点进行传输。

```mermaid
classDiagram
class SyncMethod {
+HostKey
+Meta
+Start
+ApplyGraves
+ApplyChanges
+Chunk
+ApplyChunk
+SanityCheck2
+Finish
+Abort
+Upload
+Download
}
class SyncRequest {
+headers : Map<String, String>
+body : Vec<u8>
}
class SyncResponse {
+status : StatusCode
+headers : Map<String, String>
+body : Vec<u8>
}
SyncMethod --> SyncRequest : "生成"
SyncRequest --> SyncResponse : "响应"
```

**Diagram sources**
- [rslib/src/sync/collection/protocol.rs](file://rslib/src/sync/collection/protocol.rs#L50-L100)

**Section sources**
- [rslib/src/sync/collection/protocol.rs](file://rslib/src/sync/collection/protocol.rs#L1-L112)

## 状态机转换
同步过程可以看作一个状态机，每个阶段对应一个状态，通过特定事件触发状态转换。

```mermaid
stateDiagram-v2
[*] --> 空闲
空闲 --> 元数据检查 : sync()
元数据检查 --> 删除处理 : start_and_process_deletions()
删除处理 --> 未分块变更 : process_unchunked_changes()
未分块变更 --> 下载分块 : process_chunks_from_server()
下载分块 --> 上传分块 : send_chunks_to_server()
上传分块 --> 完整性检查 : sanity_check()
完整性检查 --> 最终化 : finalize()
最终化 --> 空闲 : 完成
任何状态 --> 错误处理 : 发生错误
错误处理 --> 空闲 : 处理完成
```

**Diagram sources**
- [rslib/src/sync/collection/normal.rs](file://rslib/src/sync/collection/normal.rs#L100-L170)

**Section sources**
- [rslib/src/sync/collection/normal.rs](file://rslib/src/sync/collection/normal.rs#L1-L178)

## 错误恢复策略
Anki实现了全面的错误恢复机制，确保在各种故障情况下数据的完整性和一致性。

```mermaid
flowchart TD
Start([发生错误]) --> CheckErrorType{"错误类型"}
CheckErrorType --> NetworkError["网络错误"]
CheckErrorType --> DataError["数据错误"]
CheckErrorType --> LogicError["逻辑错误"]
NetworkError --> Retry["重试"]
DataError --> Resync["重新同步"]
LogicError --> Abort["中止并报告"]
Retry --> End([恢复])
Resync --> End
Abort --> End
```

**Diagram sources**
- [rslib/src/sync/collection/normal.rs](file://rslib/src/sync/collection/normal.rs#L140-L150)

**Section sources**
- [rslib/src/sync/collection/normal.rs](file://rslib/src/sync/collection/normal.rs#L1-L178)

## 常见问题处理
### 部分同步失败
当同步过程中断时，Anki通过事务回滚确保数据一致性，并在下次同步时重新开始。

### 数据不一致检测
系统通过完整性检查（sanity check）验证本地和远程数据的一致性，如果发现不一致，会要求全量同步。

### 版本兼容性处理
Anki通过同步版本号和客户端版本信息确保向前和向后兼容性，不兼容的客户端会被阻止同步。

**Section sources**
- [rslib/src/sync/collection/sanity.rs](file://rslib/src/sync/collection/sanity.rs#L1-L122)
- [rslib/src/sync/collection/meta.rs](file://rslib/src/sync/collection/meta.rs#L100-L185)

## 性能优化建议
### 批量处理
- 使用分块机制批量处理大量数据
- 将相关变更组合在单个请求中

### 网络超时配置
- 根据网络条件调整超时设置
- 实现重试机制处理临时网络问题

### 带宽限制
- 支持压缩传输减少带宽使用
- 提供进度报告和取消功能

**Section sources**
- [rslib/src/sync/collection/chunks.rs](file://rslib/src/sync/collection/chunks.rs#L400-L432)
- [rslib/src/sync/collection/protocol.rs](file://rslib/src/sync/collection/protocol.rs#L1-L112)