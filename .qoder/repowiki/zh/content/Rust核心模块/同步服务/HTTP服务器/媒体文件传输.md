# 媒体文件传输

<cite>
**本文档中引用的文件**  
- [media.py](file://pylib/anki/media.py)
- [mediasrv.py](file://qt/aqt/mediasrv.py)
- [mod.rs](file://rslib/src/media/mod.rs)
- [files.rs](file://rslib/src/media/files.rs)
- [check.rs](file://rslib/src/media/check.rs)
- [service.rs](file://rslib/src/media/service.rs)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构概述](#架构概述)
5. [详细组件分析](#详细组件分析)
6. [依赖分析](#依赖分析)
7. [性能考虑](#性能考虑)
8. [故障排除指南](#故障排除指南)
9. [结论](#结论)

## 简介
本文档深入分析Anki同步HTTP服务器中媒体文件传输功能的实现机制。重点解析`media_manager`模块中的媒体文件上传、下载、完整性校验、元数据管理及缓存策略。文档为初学者提供媒体同步流程的概念性解释，同时为高级开发者解析性能优化技巧。

## 项目结构
Anki的媒体文件传输功能分布在多个模块中，主要涉及Rust后端逻辑和Python前端服务。核心功能位于`rslib/src/media`目录下，而HTTP服务器实现位于`qt/aqt/mediasrv.py`。

```mermaid
graph TD
subgraph "前端"
mediasrv[mediasrv.py]
end
subgraph "后端"
media_mod[mod.rs]
media_files[files.rs]
media_check[check.rs]
media_service[service.rs]
end
mediasrv --> media_service
media_service --> media_mod
media_mod --> media_files
media_mod --> media_check
```

**Diagram sources**
- [mediasrv.py](file://qt/aqt/mediasrv.py)
- [mod.rs](file://rslib/src/media/mod.rs)
- [files.rs](file://rslib/src/media/files.rs)
- [check.rs](file://rslib/src/media/check.rs)
- [service.rs](file://rslib/src/media/service.rs)

**Section sources**
- [mediasrv.py](file://qt/aqt/mediasrv.py)
- [mod.rs](file://rslib/src/media/mod.rs)

## 核心组件
媒体文件传输系统由多个核心组件构成，包括媒体管理器、文件操作模块、完整性检查器和HTTP服务器。这些组件协同工作，确保媒体文件的安全传输和完整性。

**Section sources**
- [mod.rs](file://rslib/src/media/mod.rs)
- [media.py](file://pylib/anki/media.py)

## 架构概述
Anki的媒体文件传输架构采用分层设计，将HTTP服务、业务逻辑和文件操作分离。Rust后端处理核心逻辑，Python前端提供HTTP接口。

```mermaid
graph TB
subgraph "HTTP层"
mediasrv[mediasrv.py]
end
subgraph "业务逻辑层"
service[service.rs]
mod[mod.rs]
end
subgraph "数据访问层"
files[files.rs]
check[check.rs]
end
subgraph "存储层"
media_folder[媒体文件夹]
media_db[媒体数据库]
end
mediasrv --> service
service --> mod
mod --> files
mod --> check
files --> media_folder
mod --> media_db
```

**Diagram sources**
- [mediasrv.py](file://qt/aqt/mediasrv.py)
- [service.rs](file://rslib/src/media/service.rs)
- [mod.rs](file://rslib/src/media/mod.rs)
- [files.rs](file://rslib/src/media/files.rs)
- [check.rs](file://rslib/src/media/check.rs)

## 详细组件分析

### 媒体管理器分析
`MediaManager`是媒体文件传输的核心组件，负责管理媒体文件的生命周期。

```mermaid
classDiagram
class MediaManager {
+db : MediaDatabase
+media_folder : PathBuf
+add_file(desired_name : &str, data : &[u8]) : Result<Cow<str>>
+remove_files(filenames : &[S]) : Result<()>
+transact(func : FnOnce(&MediaDatabase) -> Result<T>) : Result<T>
+sync_media(progress : ThrottlingProgressHandler, auth : SyncAuth, client : Client, server_usn : Option<Usn>) : Result<()>
+all_checksums_after_checking(progress : impl FnMut(usize) -> bool) : Result<HashMap<String, Sha1Hash>>
}
class MediaDatabase {
+new(path : &Path) : Result<Self>
+transact(func : FnOnce(&mut Self) -> Result<T>) : Result<T>
+get_entry(fname : &str) : Result<Option<MediaEntry>>
+set_entry(entry : &MediaEntry) : Result<()>
+get_meta() : Result<MediaMeta>
+set_meta(meta : &MediaMeta) : Result<()>
+all_registered_checksums() : Result<HashMap<String, [u8; 20]>>
}
MediaManager --> MediaDatabase : "使用"
```

**Diagram sources**
- [mod.rs](file://rslib/src/media/mod.rs)
- [files.rs](file://rslib/src/media/files.rs)

**Section sources**
- [mod.rs](file://rslib/src/media/mod.rs)

### 文件操作分析
文件操作模块负责媒体文件的底层读写、哈希计算和文件名规范化。

```mermaid
flowchart TD
Start([开始]) --> Normalize["规范化文件名"]
Normalize --> CheckExist["检查文件是否存在"]
CheckExist --> FileExists{"文件存在?"}
FileExists --> |否| WriteFile["写入文件"]
FileExists --> |是| CalcHash["计算哈希值"]
CalcHash --> CompareHash{"哈希值匹配?"}
CompareHash --> |是| ReturnName["返回文件名"]
CompareHash --> |否| AddHash["添加哈希后缀"]
AddHash --> WriteFile
WriteFile --> End([结束])
ReturnName --> End
```

**Diagram sources**
- [files.rs](file://rslib/src/media/files.rs)

**Section sources**
- [files.rs](file://rslib/src/media/files.rs)

### 完整性检查分析
完整性检查器负责验证媒体文件的完整性和一致性，处理文件重命名和垃圾回收。

```mermaid
sequenceDiagram
participant Checker as "MediaChecker"
participant Manager as "MediaManager"
participant Folder as "媒体文件夹"
participant DB as "媒体数据库"
Checker->>Manager : check_media_folder()
Manager->>Folder : 读取文件条目
Folder-->>Manager : 文件列表
Manager->>Checker : 返回检查结果
Checker->>Manager : check_media_references()
Manager->>DB : 获取笔记数据
DB-->>Manager : 笔记内容
Manager->>Checker : 返回引用信息
Checker->>Checker : 生成检查报告
Checker-->>调用者 : 返回检查结果
```

**Diagram sources**
- [check.rs](file://rslib/src/media/check.rs)

**Section sources**
- [check.rs](file://rslib/src/media/check.rs)

### HTTP服务器分析
HTTP服务器处理媒体文件的网络传输请求，提供RESTful接口。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Server as "MediaServer"
participant Backend as "后端服务"
Client->>Server : GET /media/filename
Server->>Server : 验证请求
Server->>Backend : 处理文件请求
Backend->>Backend : 检查文件存在性
Backend->>Server : 返回文件数据
Server->>Client : 发送文件
Client->>Server : POST /add_media
Server->>Server : 验证权限
Server->>Backend : 调用add_media_file
Backend->>Backend : 存储文件并更新数据库
Backend-->>Server : 返回结果
Server-->>Client : 返回响应
```

**Diagram sources**
- [mediasrv.py](file://qt/aqt/mediasrv.py)

**Section sources**
- [mediasrv.py](file://qt/aqt/mediasrv.py)

## 依赖分析
媒体文件传输功能依赖于多个外部库和内部模块，形成复杂的依赖关系网络。

```mermaid
graph TD
media_manager --> reqwest[reqwest]
media_manager --> anki_io[anki_io]
media_manager --> regex[regex]
media_manager --> sha1[sha1]
media_manager --> unic_ucd_category[unic_ucd_category]
media_manager --> unicode_normalization[unicode_normalization]
media_manager --> tracing[tracing]
media_manager --> data_encoding[data_encoding]
media_manager --> tempfile[tempfile]
mediasrv --> flask[flask]
mediasrv --> flask_cors[flask_cors]
mediasrv --> waitress[waitress]
mediasrv --> stringcase[stringcase]
```

**Diagram sources**
- [mod.rs](file://rslib/src/media/mod.rs)
- [mediasrv.py](file://qt/aqt/mediasrv.py)

**Section sources**
- [mod.rs](file://rslib/src/media/mod.rs)
- [mediasrv.py](file://qt/aqt/mediasrv.py)

## 性能考虑
媒体文件传输系统在设计时考虑了多种性能优化策略，包括文件名规范化、哈希计算优化和并发处理。

### 文件名规范化
文件名规范化采用惰性计算和正则表达式预编译，提高处理效率。

### 哈希计算
使用SHA-1算法进行文件完整性校验，通过分块读取避免内存溢出。

### 并发处理
HTTP服务器使用多线程处理并发请求，确保高并发场景下的性能表现。

## 故障排除指南
本节提供常见问题的解决方案和调试技巧。

### 大文件传输超时
- 检查网络连接稳定性
- 调整HTTP服务器超时设置
- 使用分块传输协议

### 存储空间不足
- 清理媒体垃圾文件夹
- 检查并删除未使用的媒体文件
- 扩展存储空间

### 媒体文件损坏恢复
- 使用完整性检查功能
- 从备份恢复文件
- 重新同步媒体文件

**Section sources**
- [check.rs](file://rslib/src/media/check.rs)
- [mediasrv.py](file://qt/aqt/mediasrv.py)

## 结论
Anki的媒体文件传输系统采用分层架构设计，结合Rust后端的高性能和Python前端的灵活性，实现了可靠的媒体文件管理。系统通过哈希校验、文件名规范化和完整性检查等机制确保数据一致性，为用户提供稳定可靠的媒体同步体验。