# 复习状态

<cite>
**本文档中引用的文件**  
- [review.rs](file://rslib/src/scheduler/states/review.rs)
- [review.rs](file://rslib/src/scheduler/answering/review.rs)
- [review.rs](file://rslib/src/scheduler/service/states/review.rs)
- [mod.rs](file://rslib/src/scheduler/answering/mod.rs)
- [mod.rs](file://rslib/src/scheduler/states/mod.rs)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构概述](#架构概述)
5. [详细组件分析](#详细组件分析)
6. [依赖分析](#依赖分析)
7. [性能考虑](#性能考虑)
8. [故障排除指南](#故障排除指南)
9. [结论](#结论)

## 简介
本文档深入探讨Anki中复习状态的实现机制，重点分析`ReviewState`结构体在复习调度中的核心作用。文档详细解释了复习队列的构建、间隔调整算法、难度评级系统以及遗漏处理机制。特别关注`review.rs`文件中`ReviewState`结构体如何根据SM-2或FSRS算法计算下一个复习间隔，并描述了复习状态与学习状态、重新学习状态之间的转换逻辑。

## 项目结构
Anki的调度系统主要位于`rslib/src/scheduler`目录下，其中`states`子模块负责管理卡片的各种状态。复习状态相关的实现分散在多个文件中，核心逻辑位于`states/review.rs`，而状态转换和应用逻辑则分布在`answering`和`service/states`模块中。

```mermaid
graph TD
A[rslib/src/scheduler] --> B[states]
A --> C[answering]
A --> D[service/states]
B --> E[review.rs]
C --> F[review.rs]
D --> G[review.rs]
E --> H[ReviewState结构体]
F --> I[应用复习状态]
G --> J[状态序列化]
```

**图示来源**
- [review.rs](file://rslib/src/scheduler/states/review.rs)
- [review.rs](file://rslib/src/scheduler/answering/review.rs)
- [review.rs](file://rslib/src/scheduler/service/states/review.rs)

**本节来源**
- [review.rs](file://rslib/src/scheduler/states/review.rs)
- [mod.rs](file://rslib/src/scheduler/states/mod.rs)

## 核心组件
`ReviewState`是Anki复习系统的核心数据结构，负责存储和管理卡片的复习相关信息。该结构体包含预定天数、经过天数、难度因子、遗漏次数等关键字段，并提供了计算不同回答质量下一次复习间隔的方法。`StateContext`结构体则提供了计算所需的各种配置参数，如间隔乘数、难度因子调整值等。

**本节来源**
- [review.rs](file://rslib/src/scheduler/states/review.rs)
- [mod.rs](file://rslib/src/scheduler/states/mod.rs)

## 架构概述
Anki的复习状态管理系统采用状态模式设计，通过`CardState`枚举统一管理卡片的各种状态。当卡片处于复习状态时，系统会根据用户的回答质量（Again、Hard、Good、Easy）计算出四种可能的下一个状态。这些状态计算基于当前的`ReviewState`和`StateContext`，并考虑了FSRS算法或传统的SM-2算法。

```mermaid
classDiagram
class ReviewState {
+scheduled_days : u32
+elapsed_days : u32
+ease_factor : f32
+lapses : u32
+leeched : bool
+memory_state : Option<FsrsMemoryState>
+next_states(ctx : &StateContext) SchedulingStates
+failing_review_interval(ctx : &StateContext) (f32, Option<FsrsMemoryState>)
}
class StateContext {
+fuzz_factor : Option<f32>
+fsrs_next_states : Option<NextStates>
+hard_multiplier : f32
+easy_multiplier : f32
+interval_multiplier : f32
+maximum_review_interval : u32
+leech_threshold : u32
}
class SchedulingStates {
+current : CardState
+again : CardState
+hard : CardState
+good : CardState
+easy : CardState
}
ReviewState --> StateContext : "计算依赖"
ReviewState --> SchedulingStates : "生成"
SchedulingStates --> CardState : "包含"
```

**图示来源**
- [review.rs](file://rslib/src/scheduler/states/review.rs)
- [mod.rs](file://rslib/src/scheduler/states/mod.rs)

## 详细组件分析

### 复习状态分析
`ReviewState`结构体是Anki复习系统的核心，它不仅存储了卡片的复习状态信息，还提供了计算不同回答质量下一次复习间隔的完整逻辑。系统根据用户选择的回答质量（1-4），分别计算出Again、Hard、Good、Easy四种可能的下一个状态。

#### 复习状态类图
```mermaid
classDiagram
class ReviewState {
+scheduled_days : u32
+elapsed_days : u32
+ease_factor : f32
+lapses : u32
+leeched : bool
+memory_state : Option<FsrsMemoryState>
+days_late() i32
+interval_kind() IntervalKind
+revlog_kind() RevlogReviewKind
+next_states(ctx : &StateContext) SchedulingStates
+failing_review_interval(ctx : &StateContext) (f32, Option<FsrsMemoryState>)
+answer_again(ctx : &StateContext) CardState
+answer_hard(scheduled_days : u32, ctx : &StateContext) ReviewState
+answer_good(scheduled_days : u32, ctx : &StateContext) ReviewState
+answer_easy(scheduled_days : u32, ctx : &StateContext) ReviewState
+passing_review_intervals(ctx : &StateContext) (u32, u32, u32)
}
class StateContext {
+fuzz_factor : Option<f32>
+fsrs_next_states : Option<NextStates>
+fsrs_short_term_with_steps_enabled : bool
+fsrs_allow_short_term : bool
+steps : LearningSteps
+graduating_interval_good : u32
+graduating_interval_easy : u32
+initial_ease_factor : f32
+hard_multiplier : f32
+easy_multiplier : f32
+interval_multiplier : f32
+maximum_review_interval : u32
+leech_threshold : u32
+load_balancer_ctx : Option<LoadBalancerContext>
+relearn_steps : LearningSteps
+lapse_multiplier : f32
+minimum_lapse_interval : u32
+in_filtered_deck : bool
+preview_delays : PreviewDelays
}
ReviewState --> StateContext : "计算依赖"
```

**图示来源**
- [review.rs](file://rslib/src/scheduler/states/review.rs)

#### 状态转换序列图
```mermaid
sequenceDiagram
participant 用户 as "用户"
participant 复习器 as "复习器"
participant 状态计算 as "状态计算"
participant 状态应用 as "状态应用"
用户->>复习器 : 选择回答质量(Again/Hard/Good/Easy)
复习器->>状态计算 : get_scheduling_states(card_id)
状态计算->>状态计算 : current.next_states(ctx)
状态计算->>状态计算 : passing_review_intervals(ctx)
状态计算->>状态计算 : constrain_passing_interval()
状态计算-->>复习器 : 返回SchedulingStates
复习器->>用户 : 显示四个按钮的间隔
用户->>复习器 : 点击某个按钮
复习器->>状态应用 : answer_card(answer)
状态应用->>状态应用 : apply_study_state(current, next)
状态应用->>状态应用 : apply_review_state(current, next)
状态应用->>状态应用 : 更新卡片字段
状态应用-->>复习器 : 完成状态更新
复习器-->>用户 : 显示下一张卡片
```

**图示来源**
- [mod.rs](file://rslib/src/scheduler/answering/mod.rs)
- [review.rs](file://rslib/src/scheduler/answering/review.rs)

#### 复习间隔计算流程图
```mermaid
flowchart TD
A[开始] --> B{是否使用FSRS?}
B --> |是| C[使用FSRS状态计算间隔]
B --> |否| D{是否提前复习?}
D --> |是| E[使用提前复习间隔算法]
D --> |否| F[使用常规复习间隔算法]
C --> G[应用模糊处理]
E --> H[应用模糊处理]
F --> I[计算Hard间隔]
F --> J[计算Good间隔]
F --> K[计算Easy间隔]
I --> L[应用模糊处理]
J --> M[应用模糊处理]
K --> N[应用模糊处理]
G --> O[返回间隔]
H --> O
L --> O
M --> O
N --> O
O --> P[结束]
```

**图示来源**
- [review.rs](file://rslib/src/scheduler/states/review.rs)

**本节来源**
- [review.rs](file://rslib/src/scheduler/states/review.rs)
- [review.rs](file://rslib/src/scheduler/answering/review.rs)
- [mod.rs](file://rslib/src/scheduler/answering/mod.rs)

## 依赖分析
复习状态系统依赖于多个核心组件，包括状态上下文、学习步骤、间隔计算等。`StateContext`结构体作为依赖注入的容器，提供了计算所需的所有配置参数。系统还依赖于FSRS算法库来支持更先进的记忆模型计算。

```mermaid
graph TD
A[ReviewState] --> B[StateContext]
B --> C[LearningSteps]
B --> D[LoadBalancerContext]
B --> E[PreviewDelays]
A --> F[IntervalKind]
A --> G[RevlogReviewKind]
A --> H[FsrsMemoryState]
F --> I[时间转换]
G --> J[日志记录]
H --> K[FSRS算法]
```

**图示来源**
- [mod.rs](file://rslib/src/scheduler/states/mod.rs)
- [review.rs](file://rslib/src/scheduler/states/review.rs)

**本节来源**
- [mod.rs](file://rslib/src/scheduler/states/mod.rs)
- [review.rs](file://rslib/src/scheduler/states/review.rs)

## 性能考虑
复习状态的计算需要在用户交互的实时性要求下完成，因此性能优化至关重要。系统通过预计算所有可能的下一个状态来减少用户点击按钮时的延迟。模糊处理的随机种子基于卡片ID和复习次数生成，确保了结果的可重现性，同时避免了额外的存储开销。

## 故障排除指南
常见问题包括复习间隔计算异常、卡片难度评级不准确等。调试时应首先检查`StateContext`中的配置参数是否正确加载，特别是间隔乘数、难度因子调整值等关键参数。对于FSRS算法相关的问题，需要验证`FsrsMemoryState`是否正确初始化和更新。

**本节来源**
- [review.rs](file://rslib/src/scheduler/states/review.rs)
- [mod.rs](file://rslib/src/scheduler/answering/mod.rs)

## 结论
Anki的复习状态系统通过精心设计的状态模式和算法实现，为用户提供了一个高效、灵活的记忆管理工具。`ReviewState`结构体作为核心组件，不仅实现了传统的SM-2算法，还通过FSRS支持更先进的记忆模型。系统的模块化设计使得算法的扩展和配置的调整变得简单而安全。