# 调度队列构建

<cite>
**本文档中引用的文件**  
- [main.rs](file://rslib/src/scheduler/queue/main.rs)
- [mod.rs](file://rslib/src/scheduler/queue/builder/mod.rs)
- [gathering.rs](file://rslib/src/scheduler/queue/builder/gathering.rs)
- [sorting.rs](file://rslib/src/scheduler/queue/builder/sorting.rs)
- [intersperser.rs](file://rslib/src/scheduler/queue/builder/intersperser.rs)
- [burying.rs](file://rslib/src/scheduler/queue/builder/burying.rs)
- [sized_chain.rs](file://rslib/src/scheduler/queue/builder/sized_chain.rs)
- [mod.rs](file://rslib/src/scheduler/queue/mod.rs)
- [entry.rs](file://rslib/src/scheduler/queue/entry.rs)
- [learning.rs](file://rslib/src/scheduler/queue/learning.rs)
</cite>

## 目录
1. [简介](#简介)
2. [队列构建流程概述](#队列构建流程概述)
3. [核心组件分析](#核心组件分析)
4. [收集机制](#收集机制)
5. [排序机制](#排序机制)
6. [交错机制](#交错机制)
7. [埋藏机制](#埋藏机制)
8. [约束处理](#约束处理)
9. [常见问题与解决方案](#常见问题与解决方案)
10. [性能优化](#性能优化)
11. [结论](#结论)

## 简介
Anki的调度队列构建机制是其学习系统的核心组成部分，负责组织和管理待学习的卡片。该机制通过一系列子模块协同工作，确保用户能够按照最优的学习节奏进行复习。队列构建过程涉及卡片的收集、排序、交错和约束处理等多个环节，每个环节都有其特定的功能和实现方式。

## 队列构建流程概述

```mermaid
flowchart TD
Start([开始构建队列]) --> Gather["收集卡片\n(新卡、复习卡、学习卡)"]
Gather --> Sort["排序新卡片"]
Sort --> Merge["合并学习卡与复习卡"]
Merge --> Mix["混合新卡与复习卡"]
Mix --> Build["构建最终队列"]
Build --> End([返回队列])
```

**Diagram sources**
- [mod.rs](file://rslib/src/scheduler/queue/builder/mod.rs#L1-L547)

**Section sources**
- [mod.rs](file://rslib/src/scheduler/queue/builder/mod.rs#L1-L547)

## 核心组件分析

```mermaid
classDiagram
class QueueBuilder {
+new : Vec<NewCard>
+review : Vec<DueCard>
+learning : Vec<DueCard>
+day_learning : Vec<DueCard>
+limits : LimitTreeMap
+load_balancer : Option<LoadBalancer>
+context : Context
+new(col : &mut Collection, deck_id : DeckId) Result<Self>
+build(self, learn_ahead_secs : i64) CardQueues
+gather_cards(&mut self, col : &mut Collection) Result<()>
+sort_new(&mut self)
}
class Context {
+timing : SchedTimingToday
+config_map : HashMap<DeckConfigId, DeckConfig>
+root_deck : Deck
+sort_options : QueueSortOptions
+seen_note_ids : HashMap<NoteId, BuryMode>
+deck_map : HashMap<DeckId, Deck>
+fsrs : bool
}
class CardQueues {
+counts : Counts
+main : VecDeque<MainQueueEntry>
+intraday_learning : VecDeque<LearningQueueEntry>
+current_day : u32
+learn_ahead_secs : i64
+build_time : TimestampMillis
+current_learning_cutoff : TimestampSecs
+load_balancer : Option<LoadBalancer>
}
class Counts {
+new : usize
+learning : usize
+review : usize
}
QueueBuilder --> Context : "包含"
QueueBuilder --> CardQueues : "构建"
CardQueues --> Counts : "包含"
```

**Diagram sources**
- [mod.rs](file://rslib/src/scheduler/queue/builder/mod.rs#L1-L547)
- [mod.rs](file://rslib/src/scheduler/queue/mod.rs#L1-L302)

**Section sources**
- [mod.rs](file://rslib/src/scheduler/queue/builder/mod.rs#L1-L547)
- [mod.rs](file://rslib/src/scheduler/queue/mod.rs#L1-L302)

## 收集机制

```mermaid
flowchart TD
Start([开始收集]) --> GatherIntraday["收集当日学习卡片"]
GatherIntraday --> GatherDue["收集到期卡片\n(学习卡和复习卡)"]
GatherDue --> CheckLimit["检查根限制"]
CheckLimit --> |未达到| GatherNew["收集新卡片"]
CheckLimit --> |已达到| SkipNew["跳过新卡片收集"]
GatherNew --> DetermineOrder["确定收集顺序"]
DetermineOrder --> |按牌组| GatherByDeck["按牌组收集"]
DetermineOrder --> |按位置| GatherSorted["按排序收集"]
GatherByDeck --> End([完成收集])
GatherSorted --> End
```

**Diagram sources**
- [gathering.rs](file://rslib/src/scheduler/queue/builder/gathering.rs#L1-L177)

**Section sources**
- [gathering.rs](file://rslib/src/scheduler/queue/builder/gathering.rs#L1-L177)

## 排序机制

```mermaid
flowchart TD
Start([开始排序]) --> CheckOrder["检查新卡排序选项"]
CheckOrder --> |无排序| NoSort["保持收集顺序"]
CheckOrder --> |按模板| SortByTemplate["按模板索引排序"]
CheckOrder --> |模板+随机| SortTemplateRandom["按模板和哈希排序"]
CheckOrder --> |笔记随机+模板| SortNoteTemplate["按笔记哈希和模板排序"]
CheckOrder --> |卡片随机| SortCardRandom["按卡片ID哈希排序"]
SortByTemplate --> End([排序完成])
SortTemplateRandom --> HashNewCards["为新卡生成哈希"]
SortNoteTemplate --> HashNoteIds["为笔记ID生成哈希"]
SortCardRandom --> HashCardIds["为卡片ID生成哈希"]
HashNewCards --> SortUnstable["不稳定排序"]
HashNoteIds --> SortUnstable
HashCardIds --> SortUnstable
SortUnstable --> End
```

**Diagram sources**
- [sorting.rs](file://rslib/src/scheduler/queue/builder/sorting.rs#L1-L82)

**Section sources**
- [sorting.rs](file://rslib/src/scheduler/queue/builder/sorting.rs#L1-L82)

## 交错机制

```mermaid
flowchart TD
Start([开始交错]) --> CreateIntersperser["创建Intersperser实例"]
CreateIntersperser --> CalculateRatio["计算长度比率"]
CalculateRatio --> StoreLengths["存储两个迭代器的长度"]
StoreLengths --> InitializeIndices["初始化索引"]
InitializeIndices --> NextCard["获取下一张卡片"]
NextCard --> CheckIndices["检查索引有效性"]
CheckIndices --> |两个都有效| CompareRelative["比较相对位置"]
CheckIndices --> |仅一个有效| ReturnRemaining["返回剩余卡片"]
CheckIndices --> |都无效| End([完成交错])
CompareRelative --> |相对位置较小| ReturnTwo["返回第二个迭代器的卡片"]
CompareRelative --> |相对位置较大| ReturnOne["返回第一个迭代器的卡片"]
ReturnTwo --> End
ReturnOne --> End
ReturnRemaining --> End
```

**Diagram sources**
- [intersperser.rs](file://rslib/src/scheduler/queue/builder/intersperser.rs#L1-L134)

**Section sources**
- [intersperser.rs](file://rslib/src/scheduler/queue/builder/intersperser.rs#L1-L134)

## 埋藏机制

```mermaid
flowchart TD
Start([开始埋藏检查]) --> GetBuryMode["获取牌组埋藏模式"]
GetBuryMode --> StoreBuryMode["存储到seen_note_ids"]
StoreBuryMode --> CheckPrevious["检查之前是否见过笔记"]
CheckPrevious --> |是| UpdateBuryMode["更新埋藏模式"]
CheckPrevious --> |否| SetNewBuryMode["设置新埋藏模式"]
UpdateBuryMode --> CombineBury["合并埋藏设置"]
CombineBury --> ReturnPrevious["返回之前的埋藏模式"]
SetNewBuryMode --> ReturnNone["返回None"]
ReturnPrevious --> End([完成埋藏检查])
ReturnNone --> End
```

**Diagram sources**
- [burying.rs](file://rslib/src/scheduler/queue/builder/burying.rs#L1-L95)

**Section sources**
- [burying.rs](file://rslib/src/scheduler/queue/builder/burying.rs#L1-L95)

## 约束处理

```mermaid
flowchart TD
Start([开始约束处理]) --> CheckRootLimit["检查根限制"]
CheckRootLimit --> |已达到| SkipDeck["跳过该牌组"]
CheckRootLimit --> |未达到| CheckDeckLimit["检查牌组限制"]
CheckDeckLimit --> |已达到| Continue["继续下一个牌组"]
CheckDeckLimit --> |未达到| ProcessCards["处理卡片"]
ProcessCards --> CheckBury["检查埋藏设置"]
CheckBury --> |需要埋藏| SkipCard["跳过该卡片"]
CheckBury --> |不需要埋藏| AddCard["添加卡片到队列"]
AddCard --> DecrementLimit["递减牌组及父牌组限制"]
DecrementLimit --> Continue
Continue --> NextDeck["下一个牌组"]
NextDeck --> CheckRootLimit
SkipDeck --> End([完成约束处理])
```

**Diagram sources**
- [gathering.rs](file://rslib/src/scheduler/queue/builder/gathering.rs#L1-L177)
- [mod.rs](file://rslib/src/scheduler/queue/builder/mod.rs#L1-L547)

**Section sources**
- [gathering.rs](file://rslib/src/scheduler/queue/builder/gathering.rs#L1-L177)
- [mod.rs](file://rslib/src/scheduler/queue/builder/mod.rs#L1-L547)

## 常见问题与解决方案

### 卡片排序异常
当用户发现卡片排序不符合预期时，可能是由于以下原因：
- 牌组配置中的排序选项设置不正确
- 新卡收集优先级与排序顺序不匹配
- 哈希种子计算出现问题

**解决方案**：检查牌组配置中的`new_card_sort_order`和`new_card_gather_priority`设置，确保它们符合用户的期望。

### 队列为空
队列为空可能由以下情况导致：
- 所有牌组的每日限制都已达到
- 用户设置了不正确的牌组限制
- 牌组中没有符合条件的卡片

**解决方案**：检查牌组的每日新卡和复习卡限制，确认是否有足够的卡片可供学习。

### 埋藏功能失效
埋藏功能可能因为以下原因失效：
- 牌组配置中的埋藏选项未启用
- 笔记级别的埋藏状态未正确更新
- 系统在处理兄弟卡片时出现逻辑错误

**解决方案**：验证牌组配置中的`bury_new`、`bury_reviews`和`bury_interday_learning`设置，并检查`seen_note_ids`映射的更新逻辑。

**Section sources**
- [mod.rs](file://rslib/src/scheduler/queue/builder/mod.rs#L1-L547)
- [gathering.rs](file://rslib/src/scheduler/queue/builder/gathering.rs#L1-L177)
- [burying.rs](file://rslib/src/scheduler/queue/builder/burying.rs#L1-L95)

## 性能优化

```mermaid
flowchart TD
Start([性能优化策略]) --> UseExactSize["使用ExactSizeIterator"]
UseExactSize --> AvoidRebuild["避免不必要的队列重建"]
AvoidRebuild --> CacheResults["缓存计算结果"]
CacheResults --> EfficientSorting["高效排序算法"]
EfficientSorting --> StableSort["稳定排序用于模板排序"]
EfficientSorting --> UnstableSort["不稳定排序用于随机排序"]
StableSort --> End([优化完成])
UnstableSort --> End
UseExactSize --> SizedChain["使用SizedChain替代标准chain"]
SizedChain --> End
AvoidRebuild --> CheckStale["检查队列是否过期"]
CheckStale --> End
```

**Diagram sources**
- [sized_chain.rs](file://rslib/src/scheduler/queue/builder/sized_chain.rs#L1-L81)
- [sorting.rs](file://rslib/src/scheduler/queue/builder/sorting.rs#L1-L82)
- [mod.rs](file://rslib/src/scheduler/queue/mod.rs#L1-L302)

**Section sources**
- [sized_chain.rs](file://rslib/src/scheduler/queue/builder/sized_chain.rs#L1-L81)
- [sorting.rs](file://rslib/src/scheduler/queue/builder/sorting.rs#L1-L82)
- [mod.rs](file://rslib/src/scheduler/queue/mod.rs#L1-L302)

## 结论
Anki的调度队列构建机制是一个复杂而精密的系统，通过收集、排序、交错和约束处理等多个子模块的协同工作，为用户提供了一个高效的学习体验。该机制不仅考虑了卡片的学习状态和优先级，还充分考虑了用户的个性化设置和各种约束条件。通过深入理解这一机制的工作原理，开发者可以更好地优化系统性能，解决潜在问题，并为用户提供更加智能和个性化的学习体验。