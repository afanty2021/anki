
# 性能优化

<cite>
**本文档引用的文件**
- [sync.rs](file://rslib/src/backend/sync.rs)
- [normal.rs](file://rslib/src/sync/collection/normal.rs)
- [meta.rs](file://rslib/src/sync/collection/meta.rs)
- [start.rs](file://rslib/src/sync/collection/start.rs)
- [chunks.rs](file://rslib/src/sync/collection/chunks.rs)
- [status.rs](file://rslib/src/sync/collection/status.rs)
- [progress.rs](file://rslib/src/sync/collection/progress.rs)
- [sanity.rs](file://rslib/src/sync/collection/sanity.rs)
- [sync.py](file://qt/aqt/sync.py)
- [syncer.rs](file://rslib/src/sync/media/syncer.rs)
</cite>

## 目录
1. [引言](#引言)
2. [增量同步算法](#增量同步算法)
3. [分块传输机制](#分块传输机制)
4. [断点续传功能](#断点续传功能)
5. [大文件同步策略](#大文件同步策略)
6. [性能监控与调优](#性能监控与调优)
7. [性能测试结果](#性能测试结果)
8. [优化建议](#优化建议)
9. [结论](#结论)

## 引言
Anki同步系统采用先进的增量同步算法，确保用户在不同设备间高效、可靠地同步学习数据。本文档深入分析Anki同步性能优化的各个方面，包括变更跟踪、差异计算、数据压缩、分块传输和断点续传等核心机制。通过详细的技术分析和性能调优建议，帮助用户在各种网络条件下获得最佳的同步体验。

## 增量同步算法

Anki的增量同步算法基于USN（更新序列号）和时间戳机制，实现高效的变更跟踪和差异计算。系统通过比较本地和服务器端的元数据来确定同步需求，避免了不必要的全量同步。

```mermaid
flowchart TD
A[开始同步] --> B{本地有变更?}
B --> |否| C{服务器有变更?}
B --> |是| D[执行正常同步]
C --> |否| E[无变更]
C --> |是| D
D --> F[处理删除项]
F --> G[处理服务器变更]
G --> H[发送本地变更]
H --> I[完整性检查]
I --> J[完成同步]
```

**图示来源**
- [normal.rs](file://rslib/src/sync/collection/normal.rs#L68-L97)
- [status.rs](file://rslib/src/sync/collection/status.rs#L0-L57)

### 变更跟踪机制
Anki使用USN（更新序列号）和时间戳来跟踪数据变更。每个修改的操作都会增加USN计数器，系统通过比较USN和时间戳来确定数据的新旧状态。

```mermaid
classDiagram
class SyncMeta {
+TimestampMillis modified
+TimestampMillis schema
+Usn usn
+TimestampSecs current_time
+String server_message
+bool should_continue
+u32 host_number
+bool empty
+Usn media_usn
}
class ClientSyncState {
+SyncActionRequired required
+String server_message
+u32 host_number
+Option<String> new_endpoint
+bool local_is_newer
+Usn usn_at_last_sync
+Usn server_usn
+Usn pending_usn
+Usn server_media_usn
}
class Collection {
+sync_meta() Result<SyncMeta>
+sync_status_offline() Result<Required>
}
SyncMeta --> ClientSyncState : "比较"
Collection --> SyncMeta : "生成"
```

**图示来源**
- [meta.rs](file://rslib/src/sync/collection/meta.rs#L0-L185)
- [normal.rs](file://rslib/src/sync/collection/normal.rs#L0-L178)

### 差异计算策略
差异计算通过比较本地和服务器的元数据来确定同步操作类型。系统支持三种同步类型：无变更、正常同步和全量同步。

```mermaid
flowchart TD
A[获取本地元数据] --> B[获取服务器元数据]
B --> C{modified时间相同?}
C --> |是| D[无变更]
C --> |否| E{schema时间相同?}
E --> |是| F[正常同步]
E --> |否| G[全量同步]
```

**图示来源**
- [meta.rs](file://rslib/src/sync/collection/meta.rs#L0-L185)
- [status.rs](file://rslib/src/sync/collection/status.rs#L0-L57)

### 数据压缩方法
Anki在传输过程中采用多种数据压缩策略，包括字段分隔符优化、数据序列化和批量传输。NoteEntry和CardEntry使用元组序列化格式，减少JSON开销。

```mermaid
classDiagram
class NoteEntry {
+NoteId id
+String guid
+NotetypeId ntid
+TimestampSecs mtime
+Usn usn
+String tags
+String fields
+String sfld
+String csum
+u32 flags
+String data
}
class CardEntry {
+CardId id
+NoteId nid
+DeckId did
+u16 ord
+TimestampSecs mtime
+Usn usn
+CardType ctype
+CardQueue queue
+i32 due
+u32 ivl
+u16 factor
+u32 reps
+u32 lapses
+u32 left
+i32 odue
+DeckId odid
+u8 flags
+String data
}
class Chunk {
+bool done
+Vec<RevlogEntry> revlog
+Vec<CardEntry> cards
+Vec<NoteEntry> notes
}
Chunk --> NoteEntry : "包含"
Chunk --> CardEntry : "包含"
```

**图示来源**
- [chunks.rs](file://rslib/src/sync/collection/chunks.rs#L0-L432)
- [meta.rs](file://rslib/src/sync/collection/meta.rs#L0-L185)

**本节来源**
- [meta.rs](file://rslib/src/sync/collection/meta.rs#L0-L185)
- [chunks.rs](file://rslib/src/sync/collection/chunks.rs#L0-L432)
- [normal.rs](file://rslib/src/sync/collection/normal.rs#L0-L178)

## 分块传输机制

Anki的分块传输机制将大数据集分割成小块进行传输，提高网络效率和可靠性。系统使用固定大小的块（默认250个对象）来平衡传输效率和内存使用。

```mermaid
sequenceDiagram
participant 客户端
participant 服务器
客户端->>服务器 : start(开始同步)
服务器-->>客户端 : 返回服务器删除项
客户端->>服务器 : apply_graves(发送本地删除项)
loop 获取服务器变更
客户端->>服务器 : chunk(请求数据块)
服务器-->>客户端 : 返回数据块
客户端->>客户端 : 应用变更
end
loop 发送本地变更
客户端->>客户端 : 生成数据块
客户端->>服务器 : apply_chunk(发送数据块)
end
客户端->>服务器 : sanity_check(完整性检查)
服务器-->>客户端 : 检查结果
客户端->>服务器 : finalize(完成同步)
```

**图示来源**
- [chunks.rs](file://rslib/src/sync/collection/chunks.rs#L0-L432)
- [start.rs](file://rslib/src/sync/collection/start.rs#L0-L185)
- [normal.rs](file://rslib/src/sync/collection/normal.rs#L0-L178)

### 块大小配置
块大小通过常量CHUNK_SIZE定义，当前设置为250。这个值在内存使用和网络效率之间取得了平衡。

```mermaid
flowchart TD
A[确定块大小] --> B{对象类型}
B --> |复习记录| C[250条]
B --> |卡片| D[250张]
B --> |笔记| E[250条]
C --> F[生成数据块]
D --> F
E --> F
F --> G[序列化传输]
```

**图示来源**
- [chunks.rs](file://rslib/src/sync/collection/chunks.rs#L0-L432)

### 传输流程
分块传输遵循严格的流程，确保数据一致性和完整性。流程包括开始同步、处理删除项、获取服务器变更、发送本地变更和完整性检查。

```mermaid
flowchart TD
A[开始] --> B[启动同步]
B --> C[处理删除项]
C --> D[获取服务器变更]
D --> E{数据块完成?}
E --> |否| F[应用变更]
F --> D
E --> |是| G[发送本地变更]
G --> H{数据块完成?}
H --> |否| I[生成数据块]
I --> G
H --> |是| J[完整性检查]
J --> K[完成同步]
```

**图示来源**
- [normal.rs](file://rslib/src/sync/collection/normal.rs#L0-L178)
- [chunks.rs](file://rslib/src/sync/collection/chunks.rs#L0-L432)

**本节来源**
- [chunks.rs](file://rslib/src/sync/collection/chunks.rs#L0-L432)
- [normal.rs](file://rslib/src/sync/collection/normal.rs#L0-L178)
- [start.rs](file://rslib/src/sync/collection/start.rs#L0-L185)

## 断点续传功能

Anki的断点续传功能通过状态保持和USN跟踪实现，确保在网络中断后能够从中断点继续同步，避免重复传输已同步的数据。

```mermaid
classDiagram
class ServerSyncState {
+String skey
+Usn server_usn
+Usn client_usn
+bool client_is_newer
+Option<ChunkableIds> server_chunk_ids
}
class ChunkableIds {
+Vec<RevlogId> revlog
+Vec<CardId> cards
+Vec<NoteId> notes
}
class NormalSyncer {
+Collection col
+HttpSyncClient server
+ThrottlingProgressHandler<NormalSyncProgress> progress
}
NormalSyncer --> ServerSyncState : "使用"
NormalSyncer --> ChunkableIds : "管理"
ServerSyncState --> ChunkableIds : "存储"
```

**图示来源**
- [start.rs](file://rslib/src/sync/collection/start.rs#L0-L185)
- [chunks.rs](file://rslib/src/sync/collection/chunks.rs#L0-L432)

### 状态保持机制
系统通过ServerSyncState结构体保持同步状态，包括会话密钥、USN值和块ID列表。这些状态信息在同步过程中持续更新。

```mermaid
sequenceDiagram
    participant 客户端
    participant 服务器
    
    客户端->>服务器: start(开始)
    服务器->>服务器