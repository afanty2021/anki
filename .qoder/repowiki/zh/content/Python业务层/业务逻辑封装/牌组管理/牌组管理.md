# 牌组管理

<cite>
**本文档中引用的文件**  
- [decks.py](file://pylib/anki/decks.py)
- [mod.rs](file://rslib/src/decks/mod.rs)
- [tree.rs](file://rslib/src/decks/tree.rs)
- [service.rs](file://rslib/src/decks/service.rs)
- [filtered.rs](file://rslib/src/decks/filtered.rs)
- [deckconfig/mod.rs](file://rslib/src/deckconfig/mod.rs)
- [deckconfig/service.rs](file://rslib/src/deckconfig/service.rs)
- [filtered_deck.py](file://qt/aqt/filtered_deck.py)
</cite>

## 目录
1. [简介](#简介)
2. [牌组层次结构设计](#牌组层次结构设计)
3. [牌组配置继承机制](#牌组配置继承机制)
4. [牌组生命周期管理](#牌组生命周期管理)
5. [过滤牌组特殊行为](#过滤牌组特殊行为)
6. [牌组统计与同步](#牌组统计与同步)
7. [性能优化与边界处理](#性能优化与边界处理)
8. [最佳实践与集成细节](#最佳实践与集成细节)

## 简介
Anki牌组管理系统采用树形结构组织学习内容，支持父子牌组关系和灵活的配置继承机制。系统通过Deck类实现牌组的层次化管理，利用DeckConfig类处理配置继承和调度算法集成。牌组创建、重组和删除操作通过事务性处理确保数据一致性，同时提供过滤牌组功能实现动态卡片筛选。本系统为新手用户提供直观的牌组组织方式，为资深开发者提供与调度算法深度集成的配置选项。

## 牌组层次结构设计

Anki牌组系统采用树形结构管理牌组的层次关系，通过双冒号(::)分隔符表示父子关系。每个牌组由Deck类表示，包含唯一ID、名称、修改时间戳和配置信息。系统通过DeckTreeNode结构维护牌组树，支持高效的父子关系查询和遍历操作。

牌组名称解析遵循特定规则：名称中的双冒号表示层级分隔，如"数学::代数::线性代数"表示三层嵌套结构。系统自动维护父牌组的存在性，当创建子牌组时会自动创建缺失的中间父牌组。牌组树的根节点包含所有顶级牌组，每个节点记录其子牌组列表和折叠状态。

```mermaid
graph TD
A[根节点] --> B[默认牌组]
A --> C[数学]
A --> D[语言]
C --> E[代数]
C --> F[几何]
E --> G[线性代数]
D --> H[英语]
D --> I[法语]
```

**图示来源**
- [mod.rs](file://rslib/src/decks/mod.rs#L1-L337)
- [tree.rs](file://rslib/src/decks/tree.rs#L1-L476)

**本节来源**
- [decks.py](file://pylib/anki/decks.py#L434-L435)
- [mod.rs](file://rslib/src/decks/mod.rs#L1-L337)

## 牌组配置继承机制

牌组配置通过DeckConfig类实现继承机制，支持配置的创建、更新和删除操作。每个正常牌组关联一个DeckConfigId，指向共享的配置对象。当牌组需要自定义设置时，可以创建新的配置实例或继承现有配置进行修改。

配置继承遵循以下规则：子牌组默认继承父牌组的配置ID，但可以独立修改。系统提供add_config方法创建新配置，支持从现有配置克隆。当删除配置时，所有使用该配置的牌组将自动切换到默认配置。

```mermaid
classDiagram
class DeckConfig {
+DeckConfigId id
+String name
+TimestampSecs mtime_secs
+Usn usn
+DeckConfigInner inner
+set_modified(usn Usn) void
+fsrs_params() Vec~f32~
}
class DeckConfigInner {
+Vec~f32~ learn_steps
+Vec~f32~ relearn_steps
+u32 new_per_day
+u32 reviews_per_day
+f32 initial_ease
+f32 easy_multiplier
+f32 hard_multiplier
+f32 lapse_multiplier
+f32 interval_multiplier
+u32 maximum_review_interval
+u32 minimum_lapse_interval
}
class Deck {
+DeckId id
+NativeDeckName name
+TimestampSecs mtime_secs
+Usn usn
+DeckCommon common
+DeckKind kind
+config_id() Option~DeckConfigId~
+effective_desired_retention(config DeckConfig) f32
}
Deck --> DeckConfig : "通过config_id关联"
DeckConfig --> DeckConfigInner : "包含具体配置参数"
```

**图示来源**
- [deckconfig/mod.rs](file://rslib/src/deckconfig/mod.rs#L1-L321)
- [mod.rs](file://rslib/src/decks/mod.rs#L1-L337)

**本节来源**
- [decks.py](file://pylib/anki/decks.py#L296-L298)
- [deckconfig/mod.rs](file://rslib/src/deckconfig/mod.rs#L1-L321)

## 牌组生命周期管理

牌组的创建、重组和删除操作通过事务性处理确保数据一致性。创建牌组时，系统首先检查名称是否存在，若存在则返回现有ID，否则创建新牌组。重组操作通过reparent方法实现，支持批量移动牌组到新的父节点。

删除操作采用级联删除策略，移除指定牌组及其所有子牌组。系统在删除前验证操作的合法性，确保不会删除必需的默认牌组。所有修改操作都会更新修改时间戳和USN（更新序列号），用于同步冲突检测。

牌组间卡片移动通过set_deck方法实现，批量更新卡片的牌组ID。操作过程中会同步更新相关统计信息，确保数据一致性。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant DeckManager as "牌组管理器"
participant Backend as "后端服务"
participant Storage as "存储层"
Client->>DeckManager : 创建牌组("数学 : : 代数")
DeckManager->>Backend : get_or_create_normal_deck()
Backend->>Storage : get_deck_id("数学")
Storage-->>Backend : 返回ID
Backend->>Storage : get_deck_id("数学 : : 代数")
Storage-->>Backend : 无结果
Backend->>Storage : 创建"数学"牌组
Backend->>Storage : 创建"数学 : : 代数"牌组
Storage-->>Backend : 返回牌组对象
Backend-->>DeckManager : 返回牌组
DeckManager-->>Client : 返回成功
Client->>DeckManager : 重组牌组
DeckManager->>Backend : reparent_decks()
Backend->>Storage : 更新牌组名称
loop 更新每个子牌组
Storage->>Storage : 递归更新子牌组名称
end
Storage-->>Backend : 返回结果
Backend-->>DeckManager : 返回操作变更
DeckManager-->>Client : 返回结果
```

**图示来源**
- [service.rs](file://rslib/src/decks/service.rs#L1-L321)
- [mod.rs](file://rslib/src/decks/mod.rs#L1-L337)

**本节来源**
- [decks.py](file://pylib/anki/decks.py#L136-L137)
- [decks.py](file://pylib/anki/decks.py#L281-L288)
- [service.rs](file://rslib/src/decks/service.rs#L1-L321)

## 过滤牌组特殊行为

过滤牌组是一种特殊类型的动态牌组，基于搜索条件从其他牌组中筛选卡片。与普通牌组不同，过滤牌组的配置直接嵌入牌组对象中，不通过DeckConfigId引用外部配置。

过滤牌组支持自定义学习选项，包括预览时间设置和重新安排策略。系统允许定义多个搜索条件，每个条件包含搜索查询、卡片限制和排序方式。用户可以设置"再次"、"困难"和"良好"按钮的延迟时间，实现个性化的学习节奏。

当构建过滤牌组时，系统执行搜索查询并临时移动匹配的卡片到过滤牌组。学习完成后，根据"重新安排"选项决定是否将卡片恢复到原始牌组并重置间隔。

```mermaid
classDiagram
class FilteredDeckForUpdate {
+DeckId id
+String human_name
+FilteredDeckConfig config
+bool allow_empty
}
class FilteredDeckConfig {
+bool reschedule
+Vec~SearchTerm~ search_terms
+u32 preview_again_secs
+u32 preview_hard_secs
+u32 preview_good_secs
}
class SearchTerm {
+String search
+u32 limit
+FilteredSearchOrder order
}
class FilteredSearchOrder {
+OldestReviewedFirst
+Random
+IntervalsAscending
+IntervalsDescending
+Lapses
+Added
+Due
+ReverseAdded
}
FilteredDeckForUpdate --> FilteredDeckConfig : "包含"
FilteredDeckConfig --> SearchTerm : "包含多个"
SearchTerm --> FilteredSearchOrder : "引用"
```

**图示来源**
- [filtered.rs](file://rslib/src/decks/filtered.rs#L1-L72)
- [filtered_deck.py](file://qt/aqt/filtered_deck.py#L29-L306)

**本节来源**
- [decks.py](file://pylib/anki/decks.py#L522-L529)
- [filtered.rs](file://rslib/src/decks/filtered.rs#L1-L72)

## 牌组统计与同步

牌组统计计算通过deck_tree方法实现，返回包含牌组层次结构和统计信息的树形结构。统计信息包括新卡片数、复习卡片数、学习中卡片数和总卡片数。系统在计算统计时应用每日限制，确保显示的数字反映实际可学习的卡片数量。

同步处理通过事务机制确保数据一致性。所有牌组修改操作都会更新USN和修改时间戳，用于检测同步冲突。系统在保存牌组或配置时自动处理USN的更新，支持双向同步场景。

```mermaid
flowchart TD
Start([开始计算统计]) --> GetTree["获取牌组树结构"]
GetTree --> ApplyLimits["应用每日限制"]
ApplyLimits --> SumChildren["累加子牌组统计"]
SumChildren --> CapCounts["限制卡片数量"]
CapCounts --> UpdateTotal["更新包含子牌组的总数"]
UpdateTotal --> ReturnResult["返回统计结果"]
subgraph "限制应用"
ApplyLimits --> CheckNew["检查新卡片限制"]
CheckNew --> CheckReview["检查复习限制"]
CheckReview --> CheckLearning["检查学习限制"]
end
subgraph "累加过程"
SumChildren --> LoopChild["遍历每个子牌组"]
LoopChild --> Recursive["递归计算子牌组统计"]
Recursive --> AddToParent["累加到父牌组"]
end
```

**图示来源**
- [tree.rs](file://rslib/src/decks/tree.rs#L1-L476)
- [service.rs](file://rslib/src/decks/service.rs#L1-L321)

**本节来源**
- [decks.py](file://pylib/anki/decks.py#L184-L185)
- [tree.rs](file://rslib/src/decks/tree.rs#L1-L476)

## 性能优化与边界处理

系统采用多种策略优化牌组树的性能和处理边界情况。牌组树缓存机制避免重复计算，提高访问效率。对于大型牌组结构，系统限制嵌套层级不超过99层，防止协议缓冲区解码失败。

边界情况处理包括：当删除父牌组时自动重命名子牌组以避免名称冲突；当重命名牌组导致名称冲突时自动添加"+"后缀；确保默认牌组始终存在，即使被删除也会自动重建。

系统还处理了特殊情况下的统计计算，如当牌组为空时正确显示统计信息，以及在跨天时正确处理学习卡片的解埋操作。

**本节来源**
- [tree.rs](file://rslib/src/decks/tree.rs#L1-L476)
- [mod.rs](file://rslib/src/decks/mod.rs#L1-L337)

## 最佳实践与集成细节

对于新手用户，建议采用清晰的层次结构组织牌组，如"学科::主题::子主题"的命名模式。避免过深的嵌套层级，保持牌组结构易于导航。定期清理不再使用的牌组，保持学习环境整洁。

对于资深开发者，牌组配置与调度算法深度集成。DeckConfig中的参数直接影响FSRS（自由间隔重复系统）算法的行为。通过调整initial_ease、easy_multiplier等参数，可以优化学习曲线。系统支持通过get_retention_workload方法分析不同保留率对工作量的影响，帮助优化配置。

**本节来源**
- [deckconfig/mod.rs](file://rslib/src/deckconfig/mod.rs#L1-L321)
- [decks.py](file://pylib/anki/decks.py#L296-L298)